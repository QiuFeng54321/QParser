using System.Data;
using QParser.Lexer.Tokens;

namespace QParser.Lexer.States;

public class TrieState : State
{
    private char _fromChar;
    private readonly Dictionary<char, State> _next = new();
    private TokenType? _acceptedTokenType;
    private readonly bool _canBeIdentifier;
    private bool _isAccept;

    public TrieState(State? parentState, char fromChar, bool canBeIdentifier, TokenType? acceptedTokenType = null) :
        base(parentState)
    {
        _fromChar = fromChar;
        _canBeIdentifier = canBeIdentifier;
        _acceptedTokenType = acceptedTokenType;
    }

    /// <summary>
    /// Adds an accepting entry from the trie for the string provided to be recognized as a token of the given type.<br/>
    /// If calling <code>A.Add(...)</code> then A will be treated as the root of the trie.
    /// </summary>
    /// <param name="str">String to be recognized as <paramref name="tokenType"/></param>
    /// <param name="tokenType">The kind of token for this string</param>
    /// <exception cref="InvalidConstraintException">There exists a custom transition from any trie node
    /// on the path generated by <paramref name="str"/>, possibly by calling
    /// <see cref="Add(string,QParser.Lexer.States.State)"/></exception>
    public void Add(string str, TokenType tokenType)
    {
        State cur = this;
        var canBeIdentifier = true;
        for (var index = 0; index < str.Length; index++)
        {
            var c = str[index];
            canBeIdentifier = canBeIdentifier &&
                              (index == 0 ? IdentifierState.CheckBeginning(c) : IdentifierState.CheckBody(c));
            if (cur is not TrieState curTrie)
                throw new InvalidConstraintException($"Add token {str} conflict with non-trie state");
            if (!curTrie._next.ContainsKey(c)) curTrie._next[c] = new TrieState(cur, c, canBeIdentifier);
            cur = curTrie._next[c];
        }

        if (cur is not TrieState finalTrie)
            throw new InvalidConstraintException($"Add token {str} conflict with non-trie state");

        finalTrie._acceptedTokenType = tokenType;
        finalTrie._isAccept = true;
    }

    public void Add(string str, State state)
    {
        State cur = this;
        var canBeIdentifier = true;
        for (var index = 0; index < str.Length; index++)
        {
            var c = str[index];
            canBeIdentifier = canBeIdentifier &&
                              (index == 0 ? IdentifierState.CheckBeginning(c) : IdentifierState.CheckBody(c));
            if (cur is not TrieState curTrie)
                throw new InvalidConstraintException($"Add token {str} conflict with non-trie state");
            if (index == str.Length - 1)
            {
                if (curTrie._next.TryGetValue(c, out var value) && value != state)
                    throw new InvalidConstraintException($"Trie token custom state transition conflict");
                curTrie._next[c] = state;
            }
            else if (!curTrie._next.ContainsKey(c)) curTrie._next[c] = new TrieState(cur, c, canBeIdentifier);

            cur = curTrie._next[c];
        }
    }

    public override StateTransition NextState(char c)
    {
        if (_next.TryGetValue(c, out var value)) return value.MakeTransitionToThis();
        if (((_canBeIdentifier && !IdentifierState.CheckBody(c)) || !_canBeIdentifier) && _isAccept)
            return StateTransition.Accept;
        if (_canBeIdentifier && IdentifierState.CheckBody(c))
            return new IdentifierState(this).MakeTransitionToThis();
        return StateTransition.Error;
    }

    public override Token Accept(string str)
    {
        return new Token(_acceptedTokenType ?? TokenType.Unknown, str);
    }

    public override StateTransition MakeTransitionToThis()
    {
        return new(this, ParentState is not RootState ? StateTransitionFlag.ConsumeChar : StateTransitionFlag.None);
    }

    public override bool OfferTerminate()
    {
        return true;
    }
}